from youtube_transcript_api import YouTubeTranscriptApi
import getpass
import json
import tkinter as tk
from tkinter import filedialog

DEBUG = False
DEBUG_MENU = [('en', 'Englisch', 'en (Englisch)'), ('de', 'Deutsch', 'de (Deutsch)'), ('ar', 'Arabisch', 'ar (Arabisch)'), ('bg', 'Bulgarisch', 'bg (Bulgarisch)'), ('cs', 'Tschechisch', 'cs (Tschechisch)'), ('da', 'Dänisch', 'da (Dänisch)'), ('el', 'Griechisch', 'el (Griechisch)'), ('es', 'Spanisch', 'es (Spanisch)'), ('fa', 'Persisch', 'fa (Persisch)'), ('fr', 'Französisch', 'fr (Französisch)'), ('fr-CA', 'Französisch (Kanada)', 'fr-CA (Französisch (Kanada))'), ('gl', 'Galicisch', 'gl (Galicisch)'), ('hr', 'Kroatisch', 'hr (Kroatisch)'), ('hu', 'Ungarisch', 'hu (Ungarisch)'), ('id', 'Indonesisch', 'id (Indonesisch)'), ('it', 'Italienisch', 'it (Italienisch)'), ('iw', 'Hebräisch', 'iw (Hebräisch)'), ('ja', 'Japanisch', 'ja (Japanisch)'), ('ko', 'Koreanisch', 'ko (Koreanisch)'), ('ku', 'Kurdisch', 'ku (Kurdisch)'), ('lt', 'Litauisch', 'lt (Litauisch)'), ('lv', 'Lettisch', 'lv (Lettisch)'), ('mk', 'Mazedonisch', 'mk (Mazedonisch)'), ('mn', 'Mongolisch', 'mn (Mongolisch)'), ('my', 'Birmanisch', 'my (Birmanisch)'), ('nl', 'Niederländisch', 'nl (Niederländisch)'), ('pl', 'Polnisch', 'pl (Polnisch)'), ('pt-BR', 'Portugiesisch (Brasilien)', 'pt-BR (Portugiesisch (Brasilien))'), ('pt-PT', 'Portugiesisch (Portugal)', 'pt-PT (Portugiesisch (Portugal))'), ('ro', 'Rumänisch', 'ro (Rumänisch)'), ('ru', 'Russisch', 'ru (Russisch)'), ('sk', 'Slowakisch', 'sk (Slowakisch)'), ('sq', 'Albanisch', 'sq (Albanisch)'), ('sr', 'Serbisch', 'sr (Serbisch)'), ('sv', 'Schwedisch', 'sv (Schwedisch)'), ('th', 'Thailändisch', 'th (Thailändisch)'), ('tr', 'Türkisch', 'tr (Türkisch)'), ('uk', 'Ukrainisch', 'uk (Ukrainisch)'), ('uz', 'Usbekisch', 'uz (Usbekisch)'), ('vi', 'Vietnamesisch', 'vi (Vietnamesisch)'), ('zh-CN', 'Chinesisch (China)', 'zh-CN (Chinesisch (China))'), ('zh-HK', 'Chinesisch (Hongkong)', 'zh-HK (Chinesisch (Hongkong))'), ('zh-TW', 'Chinesisch (Taiwan)', 'zh-TW (Chinesisch (Taiwan))')]

class Root(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title('Subtitle Extractor')
        self.configure(bg = COLOUR['BG_FRAME'])
        self.geometry('600x410+40+40')
        self.resizable(True, True)
        self.bg_frame = tk.Frame(self, bg = COLOUR['BG_FRAME'], bd = 0, relief = tk.GROOVE, padx = 20, pady = 20)
        self.bg_frame.pack(side="top", fill="both", expand=True)
        self.app = App(self.bg_frame)
        self.bind_all('<Return>',   self.app.validate_and_run)
        self.bind_all('<Escape>',   self.close_window)
    def close_window(self, e = None):
        self.destroy()
        
class App(tk.Frame):
    def __init__(self, root):
        super().__init__(root, bg = COLOUR['BG_FRAME_CONTRAST'], bd = 0, relief = tk.GROOVE, )
        self.pack(side="top", fill=tk.BOTH, expand=True)
        self.elements = {}
        self.colour             = tk.StringVar(self, 'DARK')
        self.outpath            = tk.StringVar(self, f'C:/Users/{getpass.getuser()}/Downloads')
        self.outpath.trace_add("write", lambda a, b, c: self.path_changed())
        self.error              = tk.StringVar(self, '') # displays all status messages prominently
        self.url_field          = tk.StringVar(self, '') if not DEBUG else tk.StringVar(self, 'youtube.com/watch?v=6Af6b_wyiwI')
        self.url_field.trace_add("write", lambda a, b, c: self.id_changed())
        self.selection          = tk.StringVar(self, 'Default: de, en') # current selected languages
        
        self.format_text        = tk.IntVar(self, 1) # what files do you want to generate
        self.format_stamps      = tk.IntVar(self, 0) # "
        self.format_json        = tk.IntVar(self, 0) # "
        self.options_known      = False # can just press button as hail mary
        self.possible_languages = [] # [(code, language, merged)]
        self.clicked_languages  = {} # dict with lang-code as key
        self.transcript_list    = None # generated by the youtube api library, contains <transcript metadata objects>
        
        ## last line:
        self.draw_GUI()

    ## The GUI ##########################################################################################

    def draw_GUI(self, e = None, *, redraw = False): # "e = None" means that I might want to call this function via an event which then wants to give its info to the function as a parameter. that's only possible if the function is ready for that. I made all functions ready for that because a whole lot changed during developement and I called almost every function via event at one point or another. you can ignore those for the most part.
        self.padding = 6
        self.columns = 6

        if redraw:
            self.master.configure(bg = COLOUR['BG_FRAME'],)
            self.master.master.configure(bg = COLOUR['BG_FRAME'],)
            self.configure(bg = COLOUR['BG_FRAME_CONTRAST'],)
        self.draw_url_field(redraw = redraw)
        self.draw_output(redraw = redraw)
        self.draw_format(redraw = redraw)
        self.draw_language(redraw = redraw)
        self.draw_other(redraw = redraw)
       
    def draw_url_field(self, e = None, *, redraw = False):
        current = 'LIGHT' if self.colour.get() == 'DARK' else 'DARK'
        if not redraw:
            self.elements['URL'] = tk.Frame(self)
            self.elements['URL'].configure(pady = self.padding)
            self.elements['URL'].columnconfigure(1, weight = 1)
            self.elements['URL'].pack(side = tk.TOP, fill = tk.X, pady = (0,0), padx = 0)
            self.elements['URL_LABEL'] = tk.Label(self.elements['URL'])
            self.elements['URL_LABEL'].configure(anchor = 'nw', font = ("Helvetica", "13"), bd = 0, justify = tk.LEFT, text = 'Please provide the YouTube URL or the video ID:', )               
            self.elements['URL_LABEL'].grid(columnspan = 3, sticky = 'NEWS', pady = (0,8))
            self.elements['URL_FIELD'] = tk.Entry(self.elements['URL'])
            self.elements['URL_FIELD'].configure( font = ("Helvetica", "13"), bd = 0,  justify = tk.LEFT, width = 40, highlightthickness = 0, textvariable = self.url_field,)    
            self.elements['URL_FIELD'].grid(columnspan = 2, row = 1, sticky = 'NEWS', ipady = 4, padx = (0,8))
            self.elements['URL_FIELD'].focus_set()
            self.elements['URL_PAD1'] = tk.Label(self.elements['URL'])
            self.elements['URL_PAD1'].configure(bd = 0, width = 12,)
            self.elements['URL_PAD1'].grid(column = 2, row = 1, sticky = 'NEWS') # emulates button
            if DEBUG: print('FRAME URL: drawn')
            ## colour options, they fit well in this space
            self.elements['COLOUR_BLOB']  = tk.Radiobutton(self.elements['URL'])
            self.elements['COLOUR_BLOB'].configure( indicatoron = False, width = 2, borderwidth = 1,
                command = self.change_colour_scheme, highlightthickness = 0, padx = 0, pady = 0,
                offrelief = tk.FLAT, relief = tk.FLAT, variable = self.colour,)
            self.elements['COLOUR_BLOB'].grid (row = 0, column = 2, sticky='NE')
            if DEBUG: print('FRAME COLOURS: drawn')
        else:
            if DEBUG: print('FRAME URL: redrawn')
            if DEBUG: print('FRAME COLOURS: redrawn')
        # whether or not redraw:
        self.elements['URL'].configure(bg = COLOUR['BG_FRAME'])
        self.elements['URL_FIELD'].configure(bg = COLOUR['BACKGROUND_ENTRY'], fg = COLOUR['TEXT'],)
        self.elements['URL_PAD1'].configure(bg = COLOUR['BG_FRAME'])
        self.elements['URL_LABEL'].configure(bg = COLOUR['BG_FRAME'], fg = COLOUR['TEXT_LABEL'],)
        self.elements['COLOUR_BLOB'].configure(activebackground = COLOURS[current]['BG_FRAME'], value = current,
                background = COLOURS[current]['BG_FRAME'], highlightbackground = COLOURS[current]['BG_FRAME'],
                highlightcolor = COLOURS[current]['BG_FRAME'], selectcolor = COLOURS[current]['BG_FRAME'],)
        
    def draw_output(self, e = None, *, redraw = False):
        if not redraw:
            self.elements['OUTPUT'] = tk.Frame(self)
            self.elements['OUTPUT'].configure(pady = self.padding, bg = COLOUR['BG_FRAME'],)
            self.elements['OUTPUT'].columnconfigure(1, weight = 1)
            self.elements['OUTPUT'].pack(side = tk.TOP, fill = tk.X, pady = (0,0), padx = 0)
            self.elements['OUTPUT_LABEL'] = tk.Label(self.elements['OUTPUT'])
            self.elements['OUTPUT_LABEL'].configure(anchor = 'nw', font = ("Helvetica", "13"), bd = 0, justify = tk.LEFT, text = 'Where should the output go? (optional)',)
            self.elements['OUTPUT_LABEL'].grid(columnspan = 5, sticky = 'NEWS', pady = (0,8))
            self.elements['OUTPUT_FIELD'] = tk.Entry(self.elements['OUTPUT'])
            self.elements['OUTPUT_FIELD'].configure(font = ("Helvetica", "13"), bd = 0,  justify = tk.LEFT, highlightthickness = 0, textvariable=self.outpath,)
            self.elements['OUTPUT_FIELD'].grid(column = 1, row = 1, sticky = 'NEWS', padx = (0,8))
            self.elements['OUTPUT_BUTTON'] = tk.Button(self.elements['OUTPUT'])
            self.elements['OUTPUT_BUTTON'].configure( bd = 1, command = self.getsaveplace, font = ("Helvetica", "13"),
                padx = 0, pady = 0,  relief = tk.RAISED, text = 'Choose...', width = 9)
            self.elements['OUTPUT_BUTTON'].grid(column = 3, row = 1, sticky = 'EW')
            if DEBUG: print('FRAME OUTPUT: drawn')
        else:
            if DEBUG: print('FRAME OUTPUT: redrawn')
        self.elements['OUTPUT'].configure(bg = COLOUR['BG_FRAME'],)
        self.elements['OUTPUT_FIELD'].configure(bg = COLOUR['BACKGROUND_ENTRY'], fg = COLOUR['TEXT'],)
        self.elements['OUTPUT_BUTTON'].configure(fg = COLOUR['TEXT_BUTTON'], bg = COLOUR['BUTTON_NORMAL'],
            activeforeground = COLOUR['ACTIVE'], activebackground = COLOUR['BUTTON_CLICKED'], highlightcolor = COLOUR['ACTIVE'],)
        self.elements['OUTPUT_LABEL'].configure(bg = COLOUR['BG_FRAME'], fg = COLOUR['TEXT_LABEL'],)

    def draw_format(self, e = None, *, redraw = False):
        if not redraw:
            self.elements['FORMAT'] = tk.Frame(self)
            self.elements['FORMAT'].configure(pady = self.padding,)
            for i in range(self.columns):
                self.elements['FORMAT'].columnconfigure(i, weight = 4)
            self.elements['FORMAT'].pack(side = tk.TOP, fill = tk.X, pady = (0,1), padx = 0)
            self.elements['FORMAT_LABEL'] = tk.Label(self.elements['FORMAT'])
            self.elements['FORMAT_LABEL'].configure(anchor = 'nw', font = ("Helvetica", "13"), bd = 0, justify = tk.LEFT, text = 'What format should the subtitles be in?',)
            self.elements['FORMAT_LABEL'].grid(columnspan = self.columns, sticky = 'NEWS', pady = (0,8))
            self.elements['FORMAT_BOX_TEXT'] = tk.Checkbutton(self.elements['FORMAT'])
            self.elements['FORMAT_BOX_TEXT'].configure(text = 'Text', variable = self.format_text, command=self.format_changed, 
                width = 4, anchor = 'nw', font = ("Helvetica", "13"), bd = 0, pady = 0, padx = 4, justify = tk.LEFT,)
            self.elements['FORMAT_BOX_TEXT'].grid(column = 0, row = 1, sticky = 'NEWS')
            self.elements['FORMAT_BOX_CUES'] = tk.Checkbutton(self.elements['FORMAT'])
            self.elements['FORMAT_BOX_CUES'].configure(text = 'JSON', variable = self.format_json, command=self.format_changed, 
                width = 4, anchor = 'nw', font = ("Helvetica", "13"), bd = 0, pady = 0, padx = 4, justify = tk.LEFT,)
            self.elements['FORMAT_BOX_CUES'].grid(column = 1, row = 1, sticky = 'NEWS')
            self.elements['FORMAT_BOX_JSON'] = tk.Checkbutton(self.elements['FORMAT'])
            self.elements['FORMAT_BOX_JSON'].configure(text = 'Timestamped', variable = self.format_stamps, command=self.format_changed, 
                anchor = 'nw', font = ("Helvetica", "13"), bd = 0, pady = 0, padx = 4, justify = tk.LEFT,)
            self.elements['FORMAT_BOX_JSON'].grid(column = 2, row = 1, sticky = 'NEWS')
            if DEBUG: print('FRAME FORMAT: drawn')
        else:
            if DEBUG: print('FRAME FORMAT: redrawn')
        self.elements['FORMAT'].configure(bg = COLOUR['BG_FRAME'],)
        self.elements['FORMAT_LABEL'].configure(bg = COLOUR['BG_FRAME'], fg = COLOUR['TEXT_LABEL'],)
        self.elements['FORMAT_BOX_TEXT'].configure(bg = COLOUR['BG_FRAME'], fg = COLOUR['TEXT_LABEL'], command=self.format_changed, width = 4, 
            selectcolor = COLOUR['BG_FRAME'], activebackground = COLOUR['BG_FRAME'],
            activeforeground = COLOUR['TEXT_LABEL'],)
        self.elements['FORMAT_BOX_CUES'].configure(bg = COLOUR['BG_FRAME'], fg = COLOUR['TEXT_LABEL'], command=self.format_changed, width = 4, 
            selectcolor = COLOUR['BG_FRAME'], activebackground = COLOUR['BG_FRAME'],
            activeforeground = COLOUR['TEXT_LABEL'],)
        self.elements['FORMAT_BOX_JSON'].configure(bg = COLOUR['BG_FRAME'], fg = COLOUR['TEXT_LABEL'], command=self.format_changed, width = 4, 
            selectcolor = COLOUR['BG_FRAME'], activebackground = COLOUR['BG_FRAME'],
            activeforeground = COLOUR['TEXT_LABEL'],)

    def draw_language(self, e = None, *, redraw = False):
        if not redraw:
            self.elements['LANGUAGE'] = tk.Frame(self)
            self.elements['LANGUAGE'].configure(pady = self.padding,)
            for i in range(self.columns):
                self.elements['LANGUAGE'].columnconfigure(i, weight = 4)
            self.elements['LANGUAGE'].pack(side = tk.TOP, fill = tk.X, pady = 1, padx = 0)
            if DEBUG: print('FRAME LANGUAGE: created')
            self.draw_language_elements()
        else:
            if DEBUG: print('FRAME LANGUAGE: redrawn')
            self.draw_language_elements(redraw = redraw)
        self.elements['LANGUAGE'].configure(bg = COLOUR['BG_FRAME'],)

    def draw_language_elements(self, e = None, *, redraw = False):
        if not redraw:
            for widget in self.elements['LANGUAGE'].winfo_children():
                widget.destroy()
        if self.options_known:
            if not redraw:
                self.elements['LANGUAGE_LABEL'] = tk.Label(self.elements['LANGUAGE'])
                self.elements['LANGUAGE_LABEL'].configure(anchor = 'nw', font = ("Helvetica", "13"), bd = 0, 
                    justify = tk.LEFT, text = 'What language should the subtitles be in?',)
                self.elements['LANGUAGE_LABEL'].grid(columnspan = self.columns, sticky = 'NEWS', pady = (0,8))
                ## "The Options Menu"
                self.elements['CHOICE'] = tk.Menubutton(self.elements['LANGUAGE'])
                
                self.elements['CHOICE'].configure(bd = 1, justify = tk.LEFT, anchor = 'w', font = ("Helvetica", "13"),
                    padx = 0, pady = 0, relief = tk.RAISED, text = 'These are your language options:',)
                self.elements['CHOICE'].grid(column = 0, row = 1, sticky = 'EW', padx = (0,8), ipady = 4) 
                self.elements['CHOICE'].menu = tk.Menu(self.elements['CHOICE'])
                self.elements['CHOICE'].menu.configure(tearoff = 0, bd = 0, font = ("Helvetica", "13"))
                self.elements['CHOICE']['menu'] = self.elements['CHOICE'].menu
                if DEBUG:
                    self.possible_languages = DEBUG_MENU # gimme a bunch to test this
                    print('OPTIONS: loaded hardcoded list')
                for code, lang, text in self.possible_languages: # 1: the language code, 2: description and 3: both combined
                    self.clicked_languages.update({code: tk.IntVar()}) # new variable for every button, associated with the code through dict magic
                    self.elements['CHOICE'].menu.add_checkbutton(label = text,
                        variable = self.clicked_languages[code], command = self.update_selected_languages)
                self.elements['LANGUAGE_SELECTED'] = tk.Label(self.elements['LANGUAGE'])
                self.elements['LANGUAGE_SELECTED'].configure(anchor = 'nw', font = ("Helvetica", "13"), bd = 0,
                        justify = tk.LEFT, textvariable = self.selection,)
                self.elements['LANGUAGE_SELECTED'].grid(columnspan = self.columns, row=2, sticky = 'NEWS', pady = (8,8))
                ## helpful buttons
                self.elements['LANGUAGE_CLEAR'] = tk.Button(self.elements['LANGUAGE'])
                self.elements['LANGUAGE_CLEAR'].configure(bd = 1, command = self.clear_selection, font = ("Helvetica", "13"),
                    padx = 0, pady = 0,  relief = tk.RAISED, text = 'Clear all', width = 9)
                self.elements['LANGUAGE_CLEAR'].grid(row = 1, column = self.columns, )
                self.elements['LANGUAGE_ALL'] = tk.Button(self.elements['LANGUAGE'])
                self.elements['LANGUAGE_ALL'].configure(bd = 1, command = self.fill_selection, font = ("Helvetica", "13"),
                    padx = 0, pady = 0,  relief = tk.RAISED, text = 'Select all', width = 9)
                self.elements['LANGUAGE_ALL'].grid(row = 2, column = self.columns, )
                if DEBUG: print('FRAME LANGUAGE OPTIONS: drawn')   ##########################
            else:
                if DEBUG: print('FRAME LANGUAGE OPTIONS: redrawn') ########################
            self.elements['CHOICE'].configure(fg = COLOUR['TEXT'], activeforeground = COLOUR['TEXT'],
                bg = COLOUR['SELECT_BG'], activebackground = COLOUR['SELECT_BG_ACTIVE'],)
            self.elements['CHOICE'].menu.configure(activeforeground = COLOUR['CHOICE_FG_ACTIVE'],fg = COLOUR['CHOICE_FG'],
                activebackground = COLOUR['CHOICE_BG_ACTIVE'], bg = COLOUR['CHOICE_BG'],)
            self.elements['LANGUAGE_LABEL'].configure(bg = COLOUR['BG_FRAME'], fg = COLOUR['TEXT_LABEL'],)
            self.elements['LANGUAGE_SELECTED'].configure(bg = COLOUR['BG_FRAME'], fg = COLOUR['TEXT_LABEL'],)
            self.elements['LANGUAGE_CLEAR'].configure(fg = COLOUR['TEXT_BUTTON'], bg = COLOUR['BUTTON_NORMAL'],
                activeforeground = COLOUR['ACTIVE'], activebackground = COLOUR['BUTTON_CLICKED'], highlightcolor = COLOUR['ACTIVE'],)
            self.elements['LANGUAGE_ALL'].configure(fg = COLOUR['TEXT_BUTTON'], bg = COLOUR['BUTTON_NORMAL'],
                activeforeground = COLOUR['ACTIVE'], activebackground = COLOUR['BUTTON_CLICKED'], highlightcolor = COLOUR['ACTIVE'],)
            
        else:
            if not redraw:
                self.elements['LANGUAGE_LABEL'] = tk.Label(self.elements['LANGUAGE'])
                self.elements['LANGUAGE_LABEL'].configure(anchor = 'nw', font = ("Helvetica", "13"), bd = 0,
                    justify = tk.LEFT, text = 'Languages: try the default or see what\'s possible:',)
                self.elements['LANGUAGE_LABEL'].grid(columnspan = self.columns, row=0, sticky = 'NEWS', pady = (0,8))
                self.elements['LANGUAGE_BUTTON'] = tk.Button(self.elements['LANGUAGE'])
                self.elements['LANGUAGE_BUTTON'].configure(bd = 1, command = self.fetch_languages, width = 16, font = ("Helvetica", "13"),
                    padx = 0, pady = 0, relief = tk.RAISED, text = 'Ask for options',)
                self.elements['LANGUAGE_BUTTON'].grid(columnspan = 3, row = 1, sticky = 'NWS', pady = 3)
                self.elements['LANGUAGE_SELECTED'] = tk.Label(self.elements['LANGUAGE'])
                self.elements['LANGUAGE_SELECTED'].configure(anchor = 'nw', font = ("Helvetica", "13"), bd = 0, justify = tk.LEFT, textvariable = self.selection,)
                self.elements['LANGUAGE_SELECTED'].grid(columnspan = self.columns, row=2, sticky = 'NEWS', pady = (8,8))
                if DEBUG: print('FRAME LANGUAGE ASK: drawn')
            else:
                if DEBUG: print('FRAME LANGUAGE ASK: redrawn')
            self.elements['LANGUAGE_BUTTON'].configure(activebackground = COLOUR['BUTTON_CLICKED'], activeforeground = COLOUR['ACTIVE'], highlightcolor = COLOUR['ACTIVE'], fg = COLOUR['TEXT_BUTTON'], bg = COLOUR['BUTTON_NORMAL'],)
            self.elements['LANGUAGE_SELECTED'].configure(bg = COLOUR['BG_FRAME'], fg = COLOUR['TEXT_LABEL'],)
            self.elements['LANGUAGE_LABEL'].configure(bg = COLOUR['BG_FRAME'], fg = COLOUR['TEXT_LABEL'],)
        
    def draw_other(self, *, redraw = False):
        if not redraw:
            self.elements['BOTTOM'] = tk.Frame(self)
            self.elements['BOTTOM'].configure(pady = self.padding,)
            self.elements['BOTTOM'].columnconfigure(1, weight = 1)
            self.elements['BOTTOM'].pack(side = tk.TOP, fill = tk.BOTH, pady = (1, 0))
            self.elements['RUN'] = tk.Button(self.elements['BOTTOM'])
            self.elements['RUN'].configure(bd = 1, command = self.validate_and_run,  font = ("Helvetica", "13"),
                padx = 0, pady = 0, relief = tk.RAISED, text = 'Extract', width = 9,)
            self.elements['RUN'].pack(side = tk.RIGHT) 
            self.elements['STATUS'] = tk.Label(self.elements['BOTTOM'])
            self.elements['STATUS'].configure(font = ("Helvetica", "13"), bd = 0, textvariable = self.error, )
            self.elements['STATUS'].pack(side = tk.RIGHT, padx = (0,8))
            self.elements['BELOW'] = tk.Frame(self)
            self.elements['BELOW'].pack(side = tk.TOP, fill = tk.BOTH, expand = True)
            if DEBUG: print('FRAME OTHER: drawn')
        self.elements['BOTTOM'].configure(bg = COLOUR['BG_FRAME'])
        self.elements['BELOW'].configure(bg = COLOUR['BG_FRAME'])
        self.elements['RUN'].configure(activebackground = COLOUR['BUTTON_CLICKED'], activeforeground = COLOUR['ACTIVE'],
                bg = COLOUR['BUTTON_NORMAL'], fg = COLOUR['TEXT_BUTTON'], highlightcolor = COLOUR['ACTIVE'],)
        self.elements['STATUS'].configure(bg = COLOUR['BG_FRAME'], fg = COLOUR['TEXT_LABEL'], )

    ## The Functionality ################################################################################
        
    def update_selected_languages(self):
        self.error.set('')
        i=0
        selection = 'Chosen: '
        sorted_clicked_tuples = sorted(list(self.clicked_languages.items()))
        for code, clicked_var in sorted_clicked_tuples:
            if clicked_var.get() == 1:
                selection = selection + code if i==0 else selection + ', ' + code
                i+=1
        if i==0:
            selection = selection + ' -- '
            if DEBUG: print('LANGUAGE: empty selection')
        self.selection.set(selection)
        if DEBUG: print('LANGUAGE: added or removed, label changed')

    def clear_selection(self, e = None):
        self.error.set('')
        for key in self.clicked_languages.keys():
            self.clicked_languages[key].set(0)
        self.selection.set('Chosen: -- ')
        if DEBUG: print('LANGUAGE: cleared selection')

    def fill_selection(self, e = None):
        self.error.set('')
        for key in self.clicked_languages.keys():
            self.clicked_languages[key].set(1)
        self.update_selected_languages()
        if DEBUG: print('LANGUAGE: filled selection')
                
    def getsaveplace(self, e = None):
        self.error.set('')
        self.outpath.set(filedialog.askdirectory())
        if DEBUG: print('PATH_DIALOGUE: opened and closed')

    def id_changed(self, e = None):
        self.error.set('')
        if self.options_known:
            self.options_known = False
            self.transcript_list = None
            self.draw_language_elements()
            self.possible_languages = []
            self.selection.set('')
            self.draw_language_elements()
        if DEBUG: print('ID: changed')

    def format_changed(self, e = None):
        self.error.set('')
        if DEBUG: print('FORMAT: changed')

    def path_changed(self, e = None):
        self.error.set('')
        if DEBUG: print('PATH: changed')

    def change_colour_scheme(self, e = None):
        COLOUR.update(COLOURS[self.colour.get()])
        if DEBUG: print('COLOUR: changed to:', self.colour.get())
        self.draw_GUI(redraw = True)
        
    def fetch_languages(self, e = None):
        self.error.set('')
        video_id = self.extract_id()
        if video_id is None:
            if DEBUG: print('FETCH: url_field empty or wrong: ', self.error.get())
            return
        try:
            self.transcript_list = YouTubeTranscriptApi.list_transcripts(video_id)
        except Exception as e:
            if DEBUG: print('FETCH: EXCEPTION: ', e)
            self.error.set('Either your URL/ID is broken, or the API') 
            return
        temp_possible_languages = []
        for transcript in self.transcript_list:
            temp_possible_languages.append((transcript.language_code,
                                            transcript.language,
                                            ''.join((transcript.language_code, ' (', transcript.language, ')'))))
        temp_possible_languages.sort()
        for lang_tuple in temp_possible_languages:
##            if  ('en' in lang_tuple[0]):
##                self.possible_languages.insert(0, lang_tuple)
##            elif('de' in lang_tuple[0]):
##                self.possible_languages.insert(0, lang_tuple)
##            else:
                self.possible_languages.append(lang_tuple)
        if DEBUG:
            assert(len(temp_possible_languages) ==  len(self.possible_languages)), f'fetch_languages broke, orig:{temp_possible_languages}, after:{self.possible_languages}'
        self.options_known = True
        self.update_selected_languages()
        self.draw_language_elements()

    def extract_id(self, e = None):
        self.error.set('')
        try:
            url_or_id = self.url_field.get()
            if len(url_or_id) < 1:
                self.error.set('Please enter a video URL or an ID at the top')
                return None
            elif 10 < len(url_or_id) < 14:
                video_id    = url_or_id
                if DEBUG: print('ID: id')
            elif 'youtu.be' in url_or_id:
                tail            = url_or_id.split('.be/')[1]
                video_id        = tail.split('?')[0]
                if DEBUG: print('ID: short')
            elif 'youtube' in url_or_id:
                if DEBUG: print('ID: long')
                if ('/watch?' in url_or_id):
                    tail        = url_or_id.split('/watch?')[1]
                else:
                    tail        = url_or_id.split('/v/')[1]
                tail        = tail.split('&')[0]
                video_id    = tail.split('v=')[1]
            else:
                if DEBUG: print('ID: none of the above')
                self.error.set('The URL/ID is not recognizable, please double-check.')
                return None
            if DEBUG: print('ID: SUCCESS: ', video_id)
            return video_id
        except Exception as e:
            if DEBUG: print('ID: EXCEPTION: ', e)
            self.error.set('The URL/ID is not recognizable, please double-check.')
            return None
        return None
        
    def validate_and_run(self, e = None):
        self.error.set('')
        video_id = self.extract_id()
        if DEBUG: print('RUN: ', video_id)
        if video_id is None:
            return
        if '/' in self.outpath.get() or ':' in self.outpath.get():
            self.path = self.outpath.get()
            self.filename = video_id
        else:
            self.error.set('Please specify a valid output path')
            if DEBUG: print('RUN: no / found in path')
            return

        if self.format_text.get() + self.format_stamps.get() + self.format_json.get() < 1:
            self.error.set('Please specify at least one format')
            if DEBUG: print('RUN: no format selected')
            return

        selection = ['de', 'en']
        sorted_clicked_tuples = sorted(list(self.clicked_languages.items()))
        options_available = self.options_known and len(sorted_clicked_tuples) > 0
        if options_available:
            selection = []
            for code, clicked_var in sorted_clicked_tuples:
                if clicked_var.get() == 1:
                    selection.append(code)
            if DEBUG: print('RUN: codes to be fetched: ', selection)
        else:
            if DEBUG: print('RUN: fallback on default codes')
            if self.transcript_list is None:                
                if DEBUG: print('RUN: fetch transcripts')
                try:
                    self.transcript_list = YouTubeTranscriptApi.list_transcripts(video_id)
                except Exception as e:
                    if DEBUG: print('RUN: EXCEPTION: ', e)
                    self.error.set('Either your URL/ID is broken, or the API') 
                    return
        fetched_one = False
        found_status = []
        not_found_status = []
        for code in selection:
            try:
                transcript = self.transcript_list.find_transcript([code])
                cue_dict_list = transcript.fetch()
                if self.format_text.get()==1:
                    save_as_text(cue_dict_list, video_id, self.outpath.get(), code)
                if self.format_stamps.get()==1:
                    save_as_cues(cue_dict_list, video_id, self.outpath.get(), code)
                if self.format_json.get()==1:
                    save_as_json(cue_dict_list, video_id, self.outpath.get(), code)
                fetched_one = True
                found_status.append(code)
            except Exception as e:
                if DEBUG: print('RUN: EXCEPTION: ', e)
                not_found_status.append(code)
                continue   
        if not fetched_one:
            if options_available:
                self.error.set('Please select at least one language option')
            else:
                self.error.set('Neither German nor English could be aquired, they might not be available')
            return
        if len(not_found_status) > 0:
            self.error.set('Only found and downloaded: ' + str(found_status)[1:-1])
        else:
            self.error.set('Success, all transcripts downloaded!')
    

def save_as_text(cues, video_id, path, language):
    try:
        with open(''.join((path, '/', video_id, '_', language, '_text.txt')), 'w') as file:
            for cue in cues:
                file.write(cue['text'].replace('\n', ' ') + ' ')
    except Exception as e:
        if DEBUG: print('SAVE: TEXT: EXCEPTION: ', e)
def save_as_cues(cues, video_id, path, language):
    try:
        with open(''.join((path, '/', video_id, '_', language, '_cues.txt')), 'w') as file:
            for cue in cues:
                line = ''.join((str(cue['start']), ', ', str(cue['duration']), '\n', str(cue['text']), '\n'))
                file.write(line)
    except Exception as e:
        if DEBUG: print('SAVE: CUES: EXCEPTION: ', e)
def save_as_json(cues, video_id, path, language):
    try:
        with open(''.join((path, '/', video_id, '_', language, '.json')), 'w') as file:
            json.dump(cues, file)
    except Exception as e:
        if DEBUG: print('SAVE: JSON: EXCEPTION: ', e)

COLOUR = {}
COLOURS = {'DARK': {}, 'LIGHT': {}}
## DARK
COLOURS['DARK']['BG_FRAME'] = '#111111'
COLOURS['DARK']['BG_FRAME_CONTRAST'] = '#333333'
COLOURS['DARK']['TEXT'] = '#ffffff'
COLOURS['DARK']['TEXT_LABEL'] = '#ffffff'
COLOURS['DARK']['BUTTON_NORMAL'] = '#b25c11'
COLOURS['DARK']['BUTTON_CLICKED'] = '#ef760b'
COLOURS['DARK']['ACTIVE'] = '#444444'
COLOURS['DARK']['BACKGROUND_ENTRY'] = '#222222'
COLOURS['DARK']['TEXT_BUTTON'] = '#ffffff'
COLOURS['DARK']['CHOICE_BG_ACTIVE'] = '#222222'
COLOURS['DARK']['CHOICE_FG_ACTIVE'] = '#ef760b'
COLOURS['DARK']['CHOICE_BG'] = '#111111'
COLOURS['DARK']['CHOICE_FG'] = '#ffffff'
COLOURS['DARK']['SELECT_BG'] = '#222222'
COLOURS['DARK']['SELECT_BG_ACTIVE'] = '#333333'
## LIGHT
COLOURS['LIGHT']['BG_FRAME'] = '#eeeeee'
COLOURS['LIGHT']['BG_FRAME_CONTRAST'] = '#7f7f7f'
COLOURS['LIGHT']['TEXT'] = '#000000'
COLOURS['LIGHT']['TEXT_LABEL'] = '#000000'
COLOURS['LIGHT']['BUTTON_NORMAL'] = '#006AB3'
COLOURS['LIGHT']['BUTTON_CLICKED'] = '#0097f9'
COLOURS['LIGHT']['ACTIVE'] = '#444444'
COLOURS['LIGHT']['BACKGROUND_ENTRY'] = '#cccccc'
COLOURS['LIGHT']['TEXT_BUTTON'] = '#ffffff'
COLOURS['LIGHT']['CHOICE_BG_ACTIVE'] = '#444444'
COLOURS['LIGHT']['CHOICE_FG_ACTIVE'] = '#0097f9'
COLOURS['LIGHT']['CHOICE_BG'] = '#eeeeee'
COLOURS['LIGHT']['CHOICE_FG'] = '#000000'
COLOURS['LIGHT']['SELECT_BG'] = '#dddddd'
COLOURS['LIGHT']['SELECT_BG_ACTIVE'] = '#cccccc'
## SELECT INITIAL
COLOUR.update(COLOURS['DARK'])
#COLOUR = COLOURS['LIGHT']

def main():
    root = Root()
    root.mainloop()

if __name__  ==  '__main__':
    main()
